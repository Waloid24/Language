//  main        --      nucleus     (ядро)
//  =           --      assignare   (присвоить)
//  +           --      crescere    (увеличить)
//  -           --      subtrahere  (вычесть)
//  *           --      mul         (умножить)
//  /           --      partem      (делить)
//  return      --      reditum (возвращение)
//  while       --      cursus (цикл)
//  if          --      inceptus (попытка)
//  else        --      cruciatus (пытка)
//  << ... >>   --      (комментарий)
//  отрицание   --      rejectio (отказ)
//

/*

ТЕРМИНАЛ - объект, непосредственно присутствующий в словах языка, соответствующего грамматике, и 
            имеющий конкретное, неизменяемое значение.

НЕТЕРМИНАЛ - объект, обозначающий формулу, арифметическое выражение, команду и не имеющий конкретного 
                символьного значения.

ПАРСИНГ - процесс сопоставления линейной последовательности лексем (слов, токенов) естественного или формального языка с его
            формальной грамматикой. РЕЗУЛЬТАТОМ обычно является ДЕРЕВО РАЗБОРА (AST). Обычно применяется совместно
            с лексическим анализом.

ЛЕКСЕМА (ТОКЕН) — это последовательность символов в исходной программе, которая соответствует шаблону токена и 
            идентифицируется лексическим анализатором как экземпляр этого токена.
            Некоторые авторы называют это «токеном», используя «токен» взаимозаменяемо для представления 
            строки, которая токенизируется, и структуры данных токена, полученной в результате прохождения 
            этой строки через процесс токенизации.

ЛЕКСЕР - Лексический анализатор вообще ничего не делает с комбинациями токенов, задача осталась за парсером. 
            Например, типичный лексический анализатор распознает круглые скобки как токены, но ничего не делает 
            для того, чтобы каждый «(» соответствовал символу «)».

ОЦЕНЩИК (вычислитель, идентификатор) - Чтобы создать токен, лексическому анализатору требуется второй этап, 
            вычислитель , который перебирает символы лексемы для получения значения. 
            Тип лексемы в сочетании с ее значением представляет собой токен, который можно передать 
            синтаксическому анализатору. Некоторые токены, такие как круглые скобки, на самом деле 
            не имеют значений, и поэтому функция оценки для них не может ничего вернуть: нужен только тип.

пример: строка кода: net_worth_future = (assets – liabilities + 5); может быть преобразована в следующий поток
            лексических токенов; пробел подавляется, а специальные символы не имеют значения:

ИДЕНТИФИКАТОР net_worth_future
РАВНО
ОТКРЫВАЮЩАЯ КРУГЛАЯ СКОБКА
ИДЕНТИФИКАТОР assets
МИНУС
ИДЕНТИФИКАТОР liabilities
ПЛЮС
ЧИСЛО 5
ЗАКРЫВАЮЩАЯ КРУГЛАЯ СКОБКА
ТОЧКА С ЗАПЯТОЙ

внутри токена - тип + union

ТРАНСПАЙЛЕР (transpiler) — программа (тип компилятора), выполняющая транспиляцию программы.

ТРАНСПИЛЯЦИЯ — преобразование программы, при котором используется исходнный код программы, 
            написанной на одном языке программирования в качестве исходных данных, и производится эквивалентный 
            исходный код на другом языке программирования.

Compiler - построение конечного кода по AST. Этот пункт можно заменить на компиляцию в байткод,

"Идентификаторы" или "символы" (id) — это имена, выбираемые программистом для переменных, типов, функций и меток. 
                    Написание и регистр символов в именах идентификаторов должны отличаться от всех ключевых слов.

Ключевые слова - пример: return, while, if и т.д.

Операторы - +, *, /, >, =, <= и т.д.

'::=' - определяется как
'|' - символ альтернативного варианта
'+' - повторение нетерминала один или более раз
'*' - повторение нетерминала ноль или более раз
' '(' expression ')' ' - такая конструкция означает, что ожидаются фигурные скобки перед и после выражения (expression).


<...> - в угловых скобках записывается нетерминал


*********************                                ***ПЛАН***                             *********************
1) лексер
2) парсер
3) создание кода в виде push и pop
4) переработка его в числа
5) компиляция
*****************************************************************************************************************

Common grammar:

    Define          ::= TYPE_ID '(' {TYPE_ID {',' TYPE_ID}* }? ')' '{' Statement+ '}'

    Statement       ::= Assign          |
                        Conditional     |
                        Cycle           |
                        Terminational   |
                        Expression ';'

    Assign          ::= TYPE_ID '=' Expression ';' 
    Terminational   ::= 'return' Expression ';'
    Cycle           ::= 'while'  '(' Expression ')' '{' {Statement}+ '}'
    Conditional     ::= 'if'     '(' Expression ')' '{' {Statement}+ '}' { else {'{' {Statement}+ '}'} }?

    Expression      ::= Boolean {['&&', '||'] Boolean}*

    Boolean         ::= Arithmetic {['==', '!=', '>=', '<=', '>', '<'] Arithmetic}*

    Arithmetic      ::= Term {['+', '-'] Term}*

    Term            ::= Primary {['*', '/'] Primary}*

    Primary         ::= '-' Primary             |
                        '(' Expression ')'      |
                        TYPE_NUM                |
                        TYPE_ID                 |
                        TYPE_ID  '(' {Expression {',' Expression}*}? ')' | // Function call
                        TYPE_EMB '(' {Expression {',' Expression}?}? ')'   // Embedded-function call


Если нет одного из потомков, то вешаем на правую ветвь

Каждый язык программирования состоит из трёх типов выражений:
1) выражения (expressions)
2) инструкции (statements)
3) объявления (declarations)

Выражение (expression) - это формула в исходном коде. Выражение может иметь побочные эффекты: например, при вызове
функций она может что-то напечатать. Примеры:
>>> доступ к перменной: x
>>> литерал:            5.18
>>> унарный оператор:   -x
>>> бинарный оператор:  x == 7 (операторы могут быть логическими, арифметическими, сравнения)
>>> вызов функции:      sqrt(pow(x,6))

Инструкции (statement) - это действия в исходном коде. Инструкция всегда имеет побочный эффект (печать, присваиваение
переменной, смена потока управления и т.д.). В с е г д а, когда приходим на уровень s t a t e m e n t в грамматике, 
необходимо перед этим создать узел statement. Примеры:
>>> Объявление переменной: int x = 500;
>>> Присвоение переменной: num = num + 5;
>>> Условные конструкции:  if, else, if else
>>> Циклы:                 while
>>> Инструкции потока управления: например, возврат из функции - return 5;
>>> Блоки кода:            { x = 5; return x; }


Объявление (declaration) - это создание новой переменной сущности, такой как функция или тип.

TODO:
автоматическая генерация operationType из одного файла (нужно при обработке выражений >= в парсере)

Тесты:
1)
        a assignare 5


    b     assignare     7
с assignare a crescere b



*/
